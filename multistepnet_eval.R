##################################################################################################

## File name: multistepnet_sim.R
## Programmer: Elizabeth Chase
## Project: Multi-step elastic net, in collaboration with Phil Boonstra
## Date: Worked on from Oct. 1, 2017-June 1, 2018; this polished code was completed and assembled
##       for publication on May 17-May 18, 2018
## Updated on June 8, 2018 to scale AUC/Brier score, collapse the TDR, and present sensitivity in
## tabular format.
## Other related files: multistepnet_functions.R, multistepnet_sim.R
## Purpose: This file evaluates the results from the simulations generated by multistepnet_sim.R

#################################################################################################

#Loading packages
library(parallel);
library(pROC);
library(stringr);

#Set working directory:
setwd("~/Desktop/Research/Phil Elastic Net/Results/Final Final Results")

#Set source for multistepnet_functions_revised:
source("~/Desktop/Research/Phil Elastic Net/Final code/multistepnet_functions_revised.R");

# Calculate the number of cores
no_cores <- detectCores() - 1

# Initiate cluster
cl <- makeCluster(no_cores)

##############EVALUATION OF OUTPUT#######################

#First, we will extract the five different net penalties and the two SGL methods:

en <- mclapply(mynet,subnet, quelmod="en", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)
  
ipf_en <- mclapply(mynet,subnet, quelmod="ipf_en", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
  
ipf_zero <- mclapply(mynet,subnet, quelmod="ipf_zero", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

ipf_inf <- mclapply(mynet,subnet, quelmod="ipf_inf", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

ms <- mclapply(mynet,subnet, quelmod="ms", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

sgl <- mclapply(mysgl,subsgl, quelmod="sgl", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
            mc.cores=no_cores,mc.cleanup=TRUE)

glasso <- mclapply(mysgl,subsgl, quelmod="group", mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

#e.g. inspect distribution of tuning parameters
matrix(unlist(lapply(ms,"[","tuning_par")), nrow = reps, byrow=T)
matrix(unlist(lapply(sgl,"[","tuning_par")), nrow = reps, byrow=T)
#e.g. inspect distribution of model assessments (brier scores, auc)
matrix(unlist(lapply(ms,"[","assess")), nrow = reps, byrow=T)
matrix(unlist(lapply(sgl,"[","assess")), nrow = reps, byrow=T)

#e.g. inspect coefficients, RMSE, sensitivity
matrix_truebetas = matrix(truebetas, nrow = reps, ncol = length(truebetas), byrow = T);
#RMSE All betas
estbeta_ms = matrix(unlist(lapply(ms,"[","coefs")), nrow = reps, byrow=T);

mean(sqrt(rowMeans((estbeta_ms - matrix_truebetas)^2)));
#RMSE Established
mean(sqrt(rowMeans((estbeta_ms[,which_set1,drop=F] - matrix_truebetas[,which_set1,drop=F])^2)));
#RMSE Unestablished
mean(sqrt(rowMeans((estbeta_ms[,which_set2,drop=F] - matrix_truebetas[,which_set2,drop=F])^2)));

#Sensitivity, specificity All betas
matrix_abs_truebetas = abs(matrix_truebetas);
abs_estbeta_ms = abs(estbeta_ms);
sum((abs_estbeta_ms > small_number) * (matrix_abs_truebetas > small_number)) / sum(matrix_abs_truebetas > small_number);
sum((abs_estbeta_ms < small_number) * (matrix_abs_truebetas < small_number)) / sum(matrix_abs_truebetas < small_number);
#Sensitivity, specificity established
sum((abs_estbeta_ms[,which_set1,drop=F] > small_number) * (matrix_abs_truebetas[,which_set1,drop=F] > small_number)) / sum(matrix_abs_truebetas[,which_set1,drop=F] > small_number);
sum((abs_estbeta_ms[,which_set1,drop=F] < small_number) * (matrix_abs_truebetas[,which_set1,drop=F] < small_number)) / sum(matrix_abs_truebetas[,which_set1,drop=F] < small_number);
#Sensitivity, specificity established
sum((abs_estbeta_ms[,which_set2,drop=F] > small_number) * (matrix_abs_truebetas[,which_set2,drop=F] > small_number)) / sum(matrix_abs_truebetas[,which_set2,drop=F] > small_number);
sum((abs_estbeta_ms[,which_set2,drop=F] < small_number) * (matrix_abs_truebetas[,which_set2,drop=F] < small_number)) / sum(matrix_abs_truebetas[,which_set2,drop=F] < small_number);

#TDR All betas
sum((abs_estbeta_ms > small_number) * (matrix_abs_truebetas > small_number)) / sum(abs_estbeta_ms > small_number);
#TDR established
sum((abs_estbeta_ms[,which_set1,drop=F] > small_number) * (matrix_abs_truebetas[,which_set1,drop=F] > small_number)) / sum(abs_estbeta_ms[,which_set1,drop=F] > small_number);
#TDR established
sum((abs_estbeta_ms[,which_set2,drop=F] > small_number) * (matrix_abs_truebetas[,which_set2,drop=F] > small_number)) / sum(abs_estbeta_ms[,which_set2,drop=F] > small_number);



######PROBABLY CAN STOP HERE; MODEL SELECTION IS COMPLETE AT THIS POINT########







#Now we will extract the predicted values:
en_y <- mclapply(en,getys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                mc.cores=no_cores,mc.cleanup=TRUE)

ipf_en_y <- mclapply(ipf_en,getys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                mc.cores=no_cores,mc.cleanup=TRUE)

ipf_zero_y <- mclapply(ipf_zero,getys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

ipf_inf_y <- mclapply(ipf_inf,getys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

ms_y <- mclapply(ms,getys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                   mc.cores=no_cores,mc.cleanup=TRUE)

sgl_y <- mclapply(sgl,sglgetys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

glasso_y <- mclapply(glasso,sglgetys,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

#And now getting Brier Score for the straight elastic net:
bsen <- mclapply(en_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

bsenvec <- unlist(bsen)
enBrier <- median(bsenvec)

#And now getting Brier Score for the IPF-EN:
bsipf_en <- mclapply(ipf_en_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

bsipf_envec <- unlist(bsipf_en)
ipf_enBrier <- median(bsipf_envec)
bsipf_en_scale <- bsipf_envec/bsenvec

#And now getting Brier Score for the IPF-zero:
bsipf_zero <- mclapply(ipf_zero_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

bsipf_zerovec <- unlist(bsipf_zero)
ipf_zeroBrier <- median(bsipf_zerovec)
bsipf_zero_scale <- bsipf_zerovec/bsenvec

#And now getting Brier Score for the IPF-inf:
bsipf_inf <- mclapply(ipf_inf_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

bsipf_infvec <- unlist(bsipf_inf)
ipf_infBrier <- median(bsipf_infvec)
bsipf_inf_scale <- bsipf_infvec/bsenvec

#And now getting Brier Score for the multi-step net:
bsms <- mclapply(ms_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                    mc.cores=no_cores,mc.cleanup=TRUE)

bsmsvec <- unlist(bsms)
msBrier <- median(bsmsvec)
bsms_scale <- bsmsvec/bsenvec

#And now getting Brier Score for the SGL:
bssgl <- mclapply(sgl_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

bssglvec <- unlist(bssgl)
sglBrier <- median(bssglvec)
bssgl_scale <- bssglvec/bsenvec

#And now getting Brier Score for the group lasso:
bsglasso <- mclapply(glasso_y,BrierScore,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                 mc.cores=no_cores,mc.cleanup=TRUE)

bsglassovec <- unlist(bsglasso)
glassoBrier <- median(bsglassovec)
bsglasso_scale <- bsglassovec/bsenvec

#And now getting AUC for the straight elastic net:
aucen <- mclapply(en_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

aucenvec <- unlist(aucen)
enAUC <- median(aucenvec)

#And for the ipf-en:
aucipf_en <- mclapply(ipf_en_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

aucipf_envec <- unlist(aucipf_en)
ipf_enAUC <- median(aucipf_envec)
aucipf_en_scale <- aucipf_envec/aucenvec

#And for the ipf_zero:
aucipf_zero <- mclapply(ipf_zero_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                      mc.cores=no_cores,mc.cleanup=TRUE)

aucipf_zerovec <- unlist(aucipf_zero)
ipf_zeroAUC <- median(aucipf_zerovec)
aucipf_zero_scale <- aucipf_zerovec/aucenvec

#And for the ipf_inf:
aucipf_inf <- mclapply(ipf_inf_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                      mc.cores=no_cores,mc.cleanup=TRUE)

aucipf_infvec <- unlist(aucipf_inf)
ipf_infAUC <- median(aucipf_infvec)
aucipf_inf_scale <- aucipf_infvec/aucenvec

#And for the ms:
aucms <- mclapply(ms_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

aucmsvec <- unlist(aucms)
msAUC <- median(aucmsvec)
aucms_scale <- aucmsvec/aucenvec

#And for the SGL:
aucsgl <- mclapply(sgl_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

aucsglvec <- unlist(aucsgl)
sglAUC <- median(aucsglvec)
aucsgl_scale <- aucsglvec/aucenvec

#And for the group lasso:
aucglasso <- mclapply(glasso_y,getAUC,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)

aucglassovec <- unlist(aucglasso)
glassoAUC <- median(aucglassovec)
aucglasso_scale <- aucglassovec/aucenvec

#Now getting RMSE for the straight elastic net
mseen <- mclapply(en,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseEN <- sapply(mseen, "[", 1)
unestmseEN <- sapply(mseen, "[", 2)
mseEN <- sqrt((estmseEN)^2 + (unestmseEN)^2)

estmseENmed <- median(estmseEN)
unesmseENmed <- median(unestmseEN)

#Now getting RMSE for the IPF-EN
mseipfen <- mclapply(ipf_en,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseIPFENraw <- sapply(mseipfen, "[", 1)
unestmseIPFENraw <- sapply(mseipfen, "[", 2)
mseIPFEN <- (sqrt((estmseIPFENraw)^2 + (unestmseIPFENraw)^2))/mseEN
estmseIPFEN <- estmseIPFENraw/estmseEN
unestmseIPFEN <- unestmseIPFENraw/unestmseEN

estmseIPFENmed <- median(estmseIPFEN)
unesmseIPFENmed <- median(unestmseIPFEN)

#Now getting RMSE for the IPF-Zero
mseipfzero <- mclapply(ipf_zero,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseIPFZraw <- sapply(mseipfzero, "[", 1)
unestmseIPFZraw <- sapply(mseipfzero, "[", 2)
mseIPFZ <- (sqrt((estmseIPFZraw)^2 + (unestmseIPFZraw)^2))/mseEN
estmseIPFZ <- estmseIPFZraw/estmseEN
unestmseIPFZ <- unestmseIPFZraw/unestmseEN

estmseIPFZmed <- median(estmseIPFZ)
unesmseIPFZmed <- median(unestmseIPFZ)

#Now getting RMSE for the IPF-Inf
mseipfinf <- mclapply(ipf_inf,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseIPFIraw <- sapply(mseipfinf, "[", 1)
unestmseIPFIraw <- sapply(mseipfinf, "[", 2)
mseIPFI <- (sqrt((estmseIPFIraw)^2 + (unestmseIPFIraw)^2))/mseEN
estmseIPFI <- estmseIPFIraw/estmseEN
unestmseIPFI <- unestmseIPFIraw/unestmseEN

estmseIPFImed <- median(estmseIPFI)
unesmseIPFImed <- median(unestmseIPFI)

#Now getting RMSE for the MS
msems <- mclapply(ms,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseMSraw <- sapply(msems, "[", 1)
unestmseMSraw <- sapply(msems, "[", 2)
mseMS <- (sqrt((estmseMSraw)^2 + (unestmseMSraw)^2))/mseEN
estmseMS <- estmseMSraw/estmseEN
unestmseMS <- unestmseMSraw/unestmseEN

estmseMSmed <- median(estmseMS)
unesmseMSmed <- median(unestmseMS)

#Now getting RMSE for the sparse group lasso
msesgl <- mclapply(sgl,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseSGLraw <- sapply(msesgl, "[", 1)
unestmseSGLraw <- sapply(msesgl, "[", 2)
mseSGL <- (sqrt((estmseSGLraw)^2 + (unestmseSGLraw)^2))/mseEN
estmseSGL <- estmseSGLraw/estmseEN
unestmseSGL <- unestmseSGLraw/unestmseEN

estmseSGLmed <- median(estmseSGL)
unesmseSGLmed <- median(unestmseSGL)

#Now getting RMSE for the group lasso
msegroup <- mclapply(glasso,findRMSE,mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                  mc.cores=no_cores,mc.cleanup=TRUE)
estmseGLASSOraw <- sapply(msegroup, "[", 1)
unestmseGLASSOraw <- sapply(msegroup, "[", 2)
mseGLASSO <- (sqrt((estmseGLASSOraw)^2 + (unestmseGLASSOraw)^2))/mseEN
estmseGLASSO <- estmseGLASSOraw/estmseEN
unestmseGLASSO <- unestmseGLASSOraw/unestmseEN

estmseGLASSOmed <- median(estmseGLASSO)
unesmseGLASSOmed <- median(unestmseGLASSO)

#Now we will calculate the TDR and sensitivity

#First, we calculate the sensitivity on the replicate level
sensitivityEN <- mclapply(en,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                       mc.cores=no_cores,mc.cleanup=TRUE)

sensEN <- median(sapply(sensitivityEN, "[[", 1))
senseEN <- median(sapply(sensitivityEN, "[[", 2))
sensuEN <- median(sapply(sensitivityEN, "[[", 3))

sensitivityIPFEN <- mclapply(ipf_en,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                          mc.cores=no_cores,mc.cleanup=TRUE)

sensIPFEN <- median(sapply(sensitivityIPFEN, "[[", 1))
senseIPFEN <- median(sapply(sensitivityIPFEN, "[[", 2))
sensuIPFEN <- median(sapply(sensitivityIPFEN, "[[", 3))

sensitivityIPFZ <- mclapply(ipf_zero,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                             mc.cores=no_cores,mc.cleanup=TRUE)

sensIPFZ <- median(sapply(sensitivityIPFZ, "[[", 1))
senseIPFZ <- median(sapply(sensitivityIPFZ, "[[", 2))
sensuIPFZ <- median(sapply(sensitivityIPFZ, "[[", 3))

sensitivityIPFI <- mclapply(ipf_inf,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                             mc.cores=no_cores,mc.cleanup=TRUE)

sensIPFI <- median(sapply(sensitivityIPFI, "[[", 1))
senseIPFI <- median(sapply(sensitivityIPFI, "[[", 2))
sensuIPFI <- median(sapply(sensitivityIPFI, "[[", 3))

sensitivityMS <- mclapply(ms,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                             mc.cores=no_cores,mc.cleanup=TRUE)

sensMS <- median(sapply(sensitivityMS, "[[", 1))
senseMS <- median(sapply(sensitivityMS, "[[", 2))
sensuMS <- median(sapply(sensitivityMS, "[[", 3))

sensitivitySGL <- mclapply(sgl,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                             mc.cores=no_cores,mc.cleanup=TRUE)

sensSGL <- median(sapply(sensitivitySGL, "[[", 1))
senseSGL <- median(sapply(sensitivitySGL, "[[", 2))
sensuSGL <- median(sapply(sensitivitySGL, "[[", 3))

sensitivityGLASSO <- mclapply(glasso,sensitivity, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                             mc.cores=no_cores,mc.cleanup=TRUE)

sensGLASSO <- median(sapply(sensitivityGLASSO, "[[", 1))
senseGLASSO <- median(sapply(sensitivityGLASSO, "[[", 2))
sensuGLASSO <- median(sapply(sensitivityGLASSO, "[[", 3))


#Next, we calculate the attributed effect for each replicate
effectEN <- mclapply(en,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                          mc.cores=no_cores,mc.cleanup=TRUE)

estEN <- mean(sapply(effectEN, "[[",1))
unestEN <- mean(sapply(effectEN, "[[",2))

effectIPFEN <- mclapply(ipf_en,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)

estIPFEN <- mean(sapply(effectIPFEN, "[[",1))
unestIPFEN <- mean(sapply(effectIPFEN, "[[",2))

effectIPFZ <- mclapply(ipf_zero,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                        mc.cores=no_cores,mc.cleanup=TRUE)

estIPFZ <- mean(sapply(effectIPFZ, "[[",1))
unestIPFZ <- mean(sapply(effectIPFZ, "[[",2))

effectIPFI <- mclapply(ipf_inf,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                        mc.cores=no_cores,mc.cleanup=TRUE)

estIPFI <- mean(sapply(effectIPFI, "[[",1))
unestIPFI <- mean(sapply(effectIPFI, "[[",2))

effectMS <- mclapply(ms,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                        mc.cores=no_cores,mc.cleanup=TRUE)

estMS <- mean(sapply(effectMS, "[[",1))
unestMS <- mean(sapply(effectMS, "[[",2))

effectSGL <- mclapply(sgl,covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                        mc.cores=no_cores,mc.cleanup=TRUE)

estSGL <- mean(sapply(effectSGL, "[[",1))
unestSGL <- mean(sapply(effectSGL, "[[",2))

effectGLASSO <- mclapply(glasso, covariateeffect, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                        mc.cores=no_cores,mc.cleanup=TRUE)

estGLASSO <- mean(sapply(effectGLASSO, "[[",1))
unestGLASSO <- mean(sapply(effectGLASSO, "[[",2))

#Now we calculate the collapsed sensitivity and TDR for the scenario as a whole
truesigs <- rep(0,7)
truesigsu <- rep(0,7)
selsigs <- rep(0,7)
selsigsu <- rep(0,7)

for (i in 1:500) {
  truesigs[1] <- truesigs[1] + findtruesigs(en[[i]])
  truesigs[2] <- truesigs[2] + findtruesigs(ipf_en[[i]])
  truesigs[3] <- truesigs[3] + findtruesigs(ipf_zero[[i]])
  truesigs[4] <- truesigs[4] + findtruesigs(ipf_inf[[i]])
  truesigs[5] <- truesigs[5] + findtruesigs(ms[[i]])
  truesigs[6] <- truesigs[6] + findtruesigs(sgl[[i]])
  truesigs[7] <- truesigs[7] + findtruesigs(glasso[[i]])
  
  truesigsu[1] <- truesigsu[1] + findtruesigs_u(en[[i]])
  truesigsu[2] <- truesigsu[2] + findtruesigs_u(ipf_en[[i]])
  truesigsu[3] <- truesigsu[3] + findtruesigs_u(ipf_zero[[i]])
  truesigsu[4] <- truesigsu[4] + findtruesigs_u(ipf_inf[[i]])
  truesigsu[5] <- truesigsu[5] + findtruesigs_u(ms[[i]])
  truesigsu[6] <- truesigsu[6] + findtruesigs_u(sgl[[i]])
  truesigsu[7] <- truesigsu[7] + findtruesigs_u(glasso[[i]])
  
  selsigs[1] <- selsigs[1] + findselsigs(en[[i]])
  selsigs[2] <- selsigs[2] + findselsigs(ipf_en[[i]])
  selsigs[3] <- selsigs[3] + findselsigs(ipf_zero[[i]])
  selsigs[4] <- selsigs[4] + findselsigs(ipf_inf[[i]])
  selsigs[5] <- selsigs[5] + findselsigs(ms[[i]])
  selsigs[6] <- selsigs[6] + findselsigs(sgl[[i]])
  selsigs[7] <- selsigs[7] + findselsigs(glasso[[i]])
  
  selsigsu[1] <- selsigsu[1] + findselsigs_u(en[[i]])
  selsigsu[2] <- selsigsu[2] + findselsigs_u(ipf_en[[i]])
  selsigsu[3] <- selsigsu[3] + findselsigs_u(ipf_zero[[i]])
  selsigsu[4] <- selsigsu[4] + findselsigs_u(ipf_inf[[i]])
  selsigsu[5] <- selsigsu[5] + findselsigs_u(ms[[i]])
  selsigsu[6] <- selsigsu[6] + findselsigs_u(sgl[[i]])
  selsigsu[7] <- selsigsu[7] + findselsigs_u(glasso[[i]])
}

sensEN_overall <- truesigs[1]/(length(which(truebetas != 0))*500)
sensuEN_overall <- truesigsu[1]/(length(which(truebeta_myst != 0))*500)
tdrEN_overall <- truesigs[1]/selsigs[1]
tdruEN_overall <- truesigsu[1]/selsigsu[1]

sensIPFEN_overall <- truesigs[2]/(length(which(truebetas != 0))*500)
sensuIPFEN_overall <- truesigsu[2]/(length(which(truebeta_myst != 0))*500)
tdrIPFEN_overall <- truesigs[2]/selsigs[2]
tdruIPFEN_overall <- truesigsu[2]/selsigsu[2]

sensIPFZ_overall <- truesigs[3]/(length(which(truebetas != 0))*500)
sensuIPFZ_overall <- truesigsu[3]/(length(which(truebeta_myst != 0))*500)
tdrIPFZ_overall <- truesigs[3]/selsigs[3]
tdruIPFZ_overall <- truesigsu[3]/selsigsu[3]

sensIPFI_overall <- truesigs[4]/(length(which(truebetas != 0))*500)
sensuIPFI_overall <- truesigsu[4]/(length(which(truebeta_myst != 0))*500)
tdrIPFI_overall <- truesigs[4]/selsigs[4]
tdruIPFI_overall <- truesigsu[4]/selsigsu[4]

sensMS_overall <- truesigs[5]/(length(which(truebetas != 0))*500)
sensuMS_overall <- truesigsu[5]/(length(which(truebeta_myst != 0))*500)
tdrMS_overall <- truesigs[5]/selsigs[5]
tdruMS_overall <- truesigsu[5]/selsigsu[5]

sensSGL_overall <- truesigs[6]/(length(which(truebetas != 0))*500)
sensuSGL_overall <- truesigsu[6]/(length(which(truebeta_myst != 0))*500)
tdrSGL_overall <- truesigs[6]/selsigs[6]
tdruSGL_overall <- truesigsu[6]/selsigsu[6]

sensGLASSO_overall <- truesigs[7]/(length(which(truebetas != 0))*500)
sensuGLASSO_overall <- truesigsu[7]/(length(which(truebeta_myst != 0))*500)
tdrGLASSO_overall <- truesigs[7]/selsigs[7]
tdruGLASSO_overall <- truesigsu[7]/selsigsu[7]

#Now counting the number of betas selected by each method:
mybetaen <- mclapply(en,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                      mc.cores=no_cores,mc.cleanup=TRUE)
betaen <- median(sapply(mybetaen, "[[", 1))

mybetaipf_en <- mclapply(ipf_en,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)
betaipf_en <- median(sapply(mybetaipf_en, "[[", 1))

mybetaipf_zero <- mclapply(ipf_zero,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)
betaipf_zero <- median(sapply(mybetaipf_zero, "[[", 1))

mybetaipf_inf <- mclapply(ipf_inf,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                     mc.cores=no_cores,mc.cleanup=TRUE)
betaipf_inf <- median(sapply(mybetaipf_inf, "[[", 1))

mybetams <- mclapply(ms,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                          mc.cores=no_cores,mc.cleanup=TRUE)
betams <- median(sapply(mybetams, "[[", 1))

mybetasgl <- mclapply(sgl,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                      mc.cores=no_cores,mc.cleanup=TRUE)
betasgl <- median(sapply(mybetasgl, "[[", 1))

mybetaglasso <- mclapply(glasso,numbetas, mc.preschedule=TRUE,mc.set.seed=TRUE,mc.silent=TRUE,
                         mc.cores=no_cores,mc.cleanup=TRUE)
betaglasso <- median(sapply(mybetaglasso, "[[", 1))
